// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: netmap/types.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace NeoFS.API.v2.Netmap {

  /// <summary>Holder for reflection information generated from netmap/types.proto</summary>
  public static partial class TypesReflection {

    #region Descriptor
    /// <summary>File descriptor for netmap/types.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TypesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChJuZXRtYXAvdHlwZXMucHJvdG8SEG5lby5mcy52Mi5uZXRtYXAipQEKBkZp",
            "bHRlchISCgRuYW1lGAEgASgJUgRuYW1lEhAKA2tleRgCIAEoCVIDa2V5EisK",
            "Am9wGAMgASgOMhsubmVvLmZzLnYyLm5ldG1hcC5PcGVyYXRpb25SAm9wEhQK",
            "BXZhbHVlGAQgASgJUgV2YWx1ZRIyCgdmaWx0ZXJzGAUgAygLMhgubmVvLmZz",
            "LnYyLm5ldG1hcC5GaWx0ZXJSB2ZpbHRlcnMinAEKCFNlbGVjdG9yEhIKBG5h",
            "bWUYASABKAlSBG5hbWUSFAoFY291bnQYAiABKA1SBWNvdW50EjAKBmNsYXVz",
            "ZRgDIAEoDjIYLm5lby5mcy52Mi5uZXRtYXAuQ2xhdXNlUgZjbGF1c2USHAoJ",
            "YXR0cmlidXRlGAQgASgJUglhdHRyaWJ1dGUSFgoGZmlsdGVyGAUgASgJUgZm",
            "aWx0ZXIiOwoHUmVwbGljYRIUCgVjb3VudBgBIAEoDVIFY291bnQSGgoIc2Vs",
            "ZWN0b3IYAiABKAlSCHNlbGVjdG9yIu4BCg9QbGFjZW1lbnRQb2xpY3kSNQoI",
            "cmVwbGljYXMYASADKAsyGS5uZW8uZnMudjIubmV0bWFwLlJlcGxpY2FSCHJl",
            "cGxpY2FzEjYKF2NvbnRhaW5lcl9iYWNrdXBfZmFjdG9yGAIgASgNUhVjb250",
            "YWluZXJCYWNrdXBGYWN0b3ISOAoJc2VsZWN0b3JzGAMgAygLMhoubmVvLmZz",
            "LnYyLm5ldG1hcC5TZWxlY3RvclIJc2VsZWN0b3JzEjIKB2ZpbHRlcnMYBCAD",
            "KAsyGC5uZW8uZnMudjIubmV0bWFwLkZpbHRlclIHZmlsdGVycyLDAgoITm9k",
            "ZUluZm8SHQoKcHVibGljX2tleRgBIAEoDFIJcHVibGljS2V5EhgKB2FkZHJl",
            "c3MYAiABKAlSB2FkZHJlc3MSRAoKYXR0cmlidXRlcxgDIAMoCzIkLm5lby5m",
            "cy52Mi5uZXRtYXAuTm9kZUluZm8uQXR0cmlidXRlUgphdHRyaWJ1dGVzEjYK",
            "BXN0YXRlGAQgASgOMiAubmVvLmZzLnYyLm5ldG1hcC5Ob2RlSW5mby5TdGF0",
            "ZVIFc3RhdGUaTQoJQXR0cmlidXRlEhAKA2tleRgBIAEoCVIDa2V5EhQKBXZh",
            "bHVlGAIgASgJUgV2YWx1ZRIYCgdwYXJlbnRzGAMgAygJUgdwYXJlbnRzIjEK",
            "BVN0YXRlEg8KC1VOU1BFQ0lGSUVEEAASCgoGT05MSU5FEAESCwoHT0ZGTElO",
            "RRACKmcKCU9wZXJhdGlvbhIZChVPUEVSQVRJT05fVU5TUEVDSUZJRUQQABIG",
            "CgJFURABEgYKAk5FEAISBgoCR1QQAxIGCgJHRRAEEgYKAkxUEAUSBgoCTEUQ",
            "BhIGCgJPUhAHEgcKA0FORBAIKjgKBkNsYXVzZRIWChJDTEFVU0VfVU5TUEVD",
            "SUZJRUQQABIICgRTQU1FEAESDAoIRElTVElOQ1QQAkJPWjdnaXRodWIuY29t",
            "L25zcGNjLWRldi9uZW9mcy1hcGktZ28vdjIvbmV0bWFwL2dycGM7bmV0bWFw",
            "qgITTmVvRlMuQVBJLnYyLk5ldG1hcGIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::NeoFS.API.v2.Netmap.Operation), typeof(global::NeoFS.API.v2.Netmap.Clause), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::NeoFS.API.v2.Netmap.Filter), global::NeoFS.API.v2.Netmap.Filter.Parser, new[]{ "Name", "Key", "Op", "Value", "Filters" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::NeoFS.API.v2.Netmap.Selector), global::NeoFS.API.v2.Netmap.Selector.Parser, new[]{ "Name", "Count", "Clause", "Attribute", "Filter" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::NeoFS.API.v2.Netmap.Replica), global::NeoFS.API.v2.Netmap.Replica.Parser, new[]{ "Count", "Selector" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::NeoFS.API.v2.Netmap.PlacementPolicy), global::NeoFS.API.v2.Netmap.PlacementPolicy.Parser, new[]{ "Replicas", "ContainerBackupFactor", "Selectors", "Filters" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::NeoFS.API.v2.Netmap.NodeInfo), global::NeoFS.API.v2.Netmap.NodeInfo.Parser, new[]{ "PublicKey", "Address", "Attributes", "State" }, null, new[]{ typeof(global::NeoFS.API.v2.Netmap.NodeInfo.Types.State) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::NeoFS.API.v2.Netmap.NodeInfo.Types.Attribute), global::NeoFS.API.v2.Netmap.NodeInfo.Types.Attribute.Parser, new[]{ "Key", "Value", "Parents" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Operations on filters
  /// </summary>
  public enum Operation {
    /// <summary>
    /// No Operation defined
    /// </summary>
    [pbr::OriginalName("OPERATION_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Equal
    /// </summary>
    [pbr::OriginalName("EQ")] Eq = 1,
    /// <summary>
    /// Not Equal
    /// </summary>
    [pbr::OriginalName("NE")] Ne = 2,
    /// <summary>
    /// Greater then
    /// </summary>
    [pbr::OriginalName("GT")] Gt = 3,
    /// <summary>
    /// Greater or equal
    /// </summary>
    [pbr::OriginalName("GE")] Ge = 4,
    /// <summary>
    /// Less then
    /// </summary>
    [pbr::OriginalName("LT")] Lt = 5,
    /// <summary>
    /// Less or equal
    /// </summary>
    [pbr::OriginalName("LE")] Le = 6,
    /// <summary>
    /// Logical OR
    /// </summary>
    [pbr::OriginalName("OR")] Or = 7,
    /// <summary>
    /// Logical AND
    /// </summary>
    [pbr::OriginalName("AND")] And = 8,
  }

  /// <summary>
  /// Selector modifier shows how the node set will be formed. By default selector
  /// just groups nodes into a bucket by attribute, selecting nodes only by their
  /// hash distance.
  /// </summary>
  public enum Clause {
    /// <summary>
    /// No modifier defined. Will select nodes from bucket randomly.
    /// </summary>
    [pbr::OriginalName("CLAUSE_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// SAME will select only nodes having the same value of bucket attribute
    /// </summary>
    [pbr::OriginalName("SAME")] Same = 1,
    /// <summary>
    /// DISTINCT will select nodes having different values of bucket attribute
    /// </summary>
    [pbr::OriginalName("DISTINCT")] Distinct = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Filter will return the subset of nodes from `NetworkMap` or another filter's
  /// results, that will satisfy filter's conditions.
  /// </summary>
  public sealed partial class Filter : pb::IMessage<Filter> {
    private static readonly pb::MessageParser<Filter> _parser = new pb::MessageParser<Filter>(() => new Filter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Filter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::NeoFS.API.v2.Netmap.TypesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Filter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Filter(Filter other) : this() {
      name_ = other.name_;
      key_ = other.key_;
      op_ = other.op_;
      value_ = other.value_;
      filters_ = other.filters_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Filter Clone() {
      return new Filter(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Name of the filter or a reference to the named filter. '*' means
    /// application to the whole unfiltered NetworkMap. At top level it's used as a
    /// filter name. At lower levels it's considered to be a reference to another
    /// named filter
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 2;
    private string key_ = "";
    /// <summary>
    /// Key to filter
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Key {
      get { return key_; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "op" field.</summary>
    public const int OpFieldNumber = 3;
    private global::NeoFS.API.v2.Netmap.Operation op_ = global::NeoFS.API.v2.Netmap.Operation.Unspecified;
    /// <summary>
    /// Filtering operation
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::NeoFS.API.v2.Netmap.Operation Op {
      get { return op_; }
      set {
        op_ = value;
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 4;
    private string value_ = "";
    /// <summary>
    /// Value to match
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "filters" field.</summary>
    public const int FiltersFieldNumber = 5;
    private static readonly pb::FieldCodec<global::NeoFS.API.v2.Netmap.Filter> _repeated_filters_codec
        = pb::FieldCodec.ForMessage(42, global::NeoFS.API.v2.Netmap.Filter.Parser);
    private readonly pbc::RepeatedField<global::NeoFS.API.v2.Netmap.Filter> filters_ = new pbc::RepeatedField<global::NeoFS.API.v2.Netmap.Filter>();
    /// <summary>
    /// List of inner filters. Top level operation will be applied to the whole
    /// list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::NeoFS.API.v2.Netmap.Filter> Filters {
      get { return filters_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Filter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Filter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Key != other.Key) return false;
      if (Op != other.Op) return false;
      if (Value != other.Value) return false;
      if(!filters_.Equals(other.filters_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Key.Length != 0) hash ^= Key.GetHashCode();
      if (Op != global::NeoFS.API.v2.Netmap.Operation.Unspecified) hash ^= Op.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      hash ^= filters_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Key.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Key);
      }
      if (Op != global::NeoFS.API.v2.Netmap.Operation.Unspecified) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Op);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Value);
      }
      filters_.WriteTo(output, _repeated_filters_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Key.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (Op != global::NeoFS.API.v2.Netmap.Operation.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Op);
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      size += filters_.CalculateSize(_repeated_filters_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Filter other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Key.Length != 0) {
        Key = other.Key;
      }
      if (other.Op != global::NeoFS.API.v2.Netmap.Operation.Unspecified) {
        Op = other.Op;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      filters_.Add(other.filters_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Key = input.ReadString();
            break;
          }
          case 24: {
            Op = (global::NeoFS.API.v2.Netmap.Operation) input.ReadEnum();
            break;
          }
          case 34: {
            Value = input.ReadString();
            break;
          }
          case 42: {
            filters_.AddEntriesFrom(input, _repeated_filters_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Selector chooses a number of nodes from the bucket taking the nearest nodes
  /// to the provided `ContainerID` by hash distance.
  /// </summary>
  public sealed partial class Selector : pb::IMessage<Selector> {
    private static readonly pb::MessageParser<Selector> _parser = new pb::MessageParser<Selector>(() => new Selector());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Selector> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::NeoFS.API.v2.Netmap.TypesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Selector() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Selector(Selector other) : this() {
      name_ = other.name_;
      count_ = other.count_;
      clause_ = other.clause_;
      attribute_ = other.attribute_;
      filter_ = other.filter_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Selector Clone() {
      return new Selector(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Selector name to reference in object placement section
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 2;
    private uint count_;
    /// <summary>
    /// How many nodes to select from the bucket
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "clause" field.</summary>
    public const int ClauseFieldNumber = 3;
    private global::NeoFS.API.v2.Netmap.Clause clause_ = global::NeoFS.API.v2.Netmap.Clause.Unspecified;
    /// <summary>
    /// Selector modifier showing how to form a bucket
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::NeoFS.API.v2.Netmap.Clause Clause {
      get { return clause_; }
      set {
        clause_ = value;
      }
    }

    /// <summary>Field number for the "attribute" field.</summary>
    public const int AttributeFieldNumber = 4;
    private string attribute_ = "";
    /// <summary>
    /// Attribute bucket to select from
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Attribute {
      get { return attribute_; }
      set {
        attribute_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "filter" field.</summary>
    public const int FilterFieldNumber = 5;
    private string filter_ = "";
    /// <summary>
    /// Filter reference to select from
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Filter {
      get { return filter_; }
      set {
        filter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Selector);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Selector other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Count != other.Count) return false;
      if (Clause != other.Clause) return false;
      if (Attribute != other.Attribute) return false;
      if (Filter != other.Filter) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Count != 0) hash ^= Count.GetHashCode();
      if (Clause != global::NeoFS.API.v2.Netmap.Clause.Unspecified) hash ^= Clause.GetHashCode();
      if (Attribute.Length != 0) hash ^= Attribute.GetHashCode();
      if (Filter.Length != 0) hash ^= Filter.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Count != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Count);
      }
      if (Clause != global::NeoFS.API.v2.Netmap.Clause.Unspecified) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Clause);
      }
      if (Attribute.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Attribute);
      }
      if (Filter.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Filter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Count != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Count);
      }
      if (Clause != global::NeoFS.API.v2.Netmap.Clause.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Clause);
      }
      if (Attribute.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Attribute);
      }
      if (Filter.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Filter);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Selector other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Count != 0) {
        Count = other.Count;
      }
      if (other.Clause != global::NeoFS.API.v2.Netmap.Clause.Unspecified) {
        Clause = other.Clause;
      }
      if (other.Attribute.Length != 0) {
        Attribute = other.Attribute;
      }
      if (other.Filter.Length != 0) {
        Filter = other.Filter;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Count = input.ReadUInt32();
            break;
          }
          case 24: {
            Clause = (global::NeoFS.API.v2.Netmap.Clause) input.ReadEnum();
            break;
          }
          case 34: {
            Attribute = input.ReadString();
            break;
          }
          case 42: {
            Filter = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Number of object replicas in a set of nodes from the defined selector. If no
  /// selector set the root bucket containing all possible nodes will be used by
  /// default.
  /// </summary>
  public sealed partial class Replica : pb::IMessage<Replica> {
    private static readonly pb::MessageParser<Replica> _parser = new pb::MessageParser<Replica>(() => new Replica());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Replica> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::NeoFS.API.v2.Netmap.TypesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Replica() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Replica(Replica other) : this() {
      count_ = other.count_;
      selector_ = other.selector_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Replica Clone() {
      return new Replica(this);
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 1;
    private uint count_;
    /// <summary>
    /// How many object replicas to put
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "selector" field.</summary>
    public const int SelectorFieldNumber = 2;
    private string selector_ = "";
    /// <summary>
    /// Named selector bucket to put replicas
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Selector {
      get { return selector_; }
      set {
        selector_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Replica);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Replica other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Count != other.Count) return false;
      if (Selector != other.Selector) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Count != 0) hash ^= Count.GetHashCode();
      if (Selector.Length != 0) hash ^= Selector.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Count != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Count);
      }
      if (Selector.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Selector);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Count != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Count);
      }
      if (Selector.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Selector);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Replica other) {
      if (other == null) {
        return;
      }
      if (other.Count != 0) {
        Count = other.Count;
      }
      if (other.Selector.Length != 0) {
        Selector = other.Selector;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Count = input.ReadUInt32();
            break;
          }
          case 18: {
            Selector = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Set of rules to select a subset of nodes from `NetworkMap` able to store
  /// container's objects. The format is simple enough to transpile from different
  /// storage policy definition languages.
  /// </summary>
  public sealed partial class PlacementPolicy : pb::IMessage<PlacementPolicy> {
    private static readonly pb::MessageParser<PlacementPolicy> _parser = new pb::MessageParser<PlacementPolicy>(() => new PlacementPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PlacementPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::NeoFS.API.v2.Netmap.TypesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PlacementPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PlacementPolicy(PlacementPolicy other) : this() {
      replicas_ = other.replicas_.Clone();
      containerBackupFactor_ = other.containerBackupFactor_;
      selectors_ = other.selectors_.Clone();
      filters_ = other.filters_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PlacementPolicy Clone() {
      return new PlacementPolicy(this);
    }

    /// <summary>Field number for the "replicas" field.</summary>
    public const int ReplicasFieldNumber = 1;
    private static readonly pb::FieldCodec<global::NeoFS.API.v2.Netmap.Replica> _repeated_replicas_codec
        = pb::FieldCodec.ForMessage(10, global::NeoFS.API.v2.Netmap.Replica.Parser);
    private readonly pbc::RepeatedField<global::NeoFS.API.v2.Netmap.Replica> replicas_ = new pbc::RepeatedField<global::NeoFS.API.v2.Netmap.Replica>();
    /// <summary>
    /// Rules to set number of object replicas and place each one into a named
    /// bucket
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::NeoFS.API.v2.Netmap.Replica> Replicas {
      get { return replicas_; }
    }

    /// <summary>Field number for the "container_backup_factor" field.</summary>
    public const int ContainerBackupFactorFieldNumber = 2;
    private uint containerBackupFactor_;
    /// <summary>
    /// Container backup factor controls how deep NeoFS will search for nodes
    /// alternatives to include into container's nodes subset
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ContainerBackupFactor {
      get { return containerBackupFactor_; }
      set {
        containerBackupFactor_ = value;
      }
    }

    /// <summary>Field number for the "selectors" field.</summary>
    public const int SelectorsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::NeoFS.API.v2.Netmap.Selector> _repeated_selectors_codec
        = pb::FieldCodec.ForMessage(26, global::NeoFS.API.v2.Netmap.Selector.Parser);
    private readonly pbc::RepeatedField<global::NeoFS.API.v2.Netmap.Selector> selectors_ = new pbc::RepeatedField<global::NeoFS.API.v2.Netmap.Selector>();
    /// <summary>
    /// Set of Selectors to form the container's nodes subset
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::NeoFS.API.v2.Netmap.Selector> Selectors {
      get { return selectors_; }
    }

    /// <summary>Field number for the "filters" field.</summary>
    public const int FiltersFieldNumber = 4;
    private static readonly pb::FieldCodec<global::NeoFS.API.v2.Netmap.Filter> _repeated_filters_codec
        = pb::FieldCodec.ForMessage(34, global::NeoFS.API.v2.Netmap.Filter.Parser);
    private readonly pbc::RepeatedField<global::NeoFS.API.v2.Netmap.Filter> filters_ = new pbc::RepeatedField<global::NeoFS.API.v2.Netmap.Filter>();
    /// <summary>
    /// List of named filters to reference in selectors
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::NeoFS.API.v2.Netmap.Filter> Filters {
      get { return filters_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PlacementPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PlacementPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!replicas_.Equals(other.replicas_)) return false;
      if (ContainerBackupFactor != other.ContainerBackupFactor) return false;
      if(!selectors_.Equals(other.selectors_)) return false;
      if(!filters_.Equals(other.filters_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= replicas_.GetHashCode();
      if (ContainerBackupFactor != 0) hash ^= ContainerBackupFactor.GetHashCode();
      hash ^= selectors_.GetHashCode();
      hash ^= filters_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      replicas_.WriteTo(output, _repeated_replicas_codec);
      if (ContainerBackupFactor != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(ContainerBackupFactor);
      }
      selectors_.WriteTo(output, _repeated_selectors_codec);
      filters_.WriteTo(output, _repeated_filters_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += replicas_.CalculateSize(_repeated_replicas_codec);
      if (ContainerBackupFactor != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContainerBackupFactor);
      }
      size += selectors_.CalculateSize(_repeated_selectors_codec);
      size += filters_.CalculateSize(_repeated_filters_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PlacementPolicy other) {
      if (other == null) {
        return;
      }
      replicas_.Add(other.replicas_);
      if (other.ContainerBackupFactor != 0) {
        ContainerBackupFactor = other.ContainerBackupFactor;
      }
      selectors_.Add(other.selectors_);
      filters_.Add(other.filters_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            replicas_.AddEntriesFrom(input, _repeated_replicas_codec);
            break;
          }
          case 16: {
            ContainerBackupFactor = input.ReadUInt32();
            break;
          }
          case 26: {
            selectors_.AddEntriesFrom(input, _repeated_selectors_codec);
            break;
          }
          case 34: {
            filters_.AddEntriesFrom(input, _repeated_filters_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// NeoFS node description
  /// </summary>
  public sealed partial class NodeInfo : pb::IMessage<NodeInfo> {
    private static readonly pb::MessageParser<NodeInfo> _parser = new pb::MessageParser<NodeInfo>(() => new NodeInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::NeoFS.API.v2.Netmap.TypesReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeInfo(NodeInfo other) : this() {
      publicKey_ = other.publicKey_;
      address_ = other.address_;
      attributes_ = other.attributes_.Clone();
      state_ = other.state_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeInfo Clone() {
      return new NodeInfo(this);
    }

    /// <summary>Field number for the "public_key" field.</summary>
    public const int PublicKeyFieldNumber = 1;
    private pb::ByteString publicKey_ = pb::ByteString.Empty;
    /// <summary>
    /// Public key of the NeoFS node in a binary format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString PublicKey {
      get { return publicKey_; }
      set {
        publicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 2;
    private string address_ = "";
    /// <summary>
    /// Ways to connect to a node
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Address {
      get { return address_; }
      set {
        address_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::NeoFS.API.v2.Netmap.NodeInfo.Types.Attribute> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(26, global::NeoFS.API.v2.Netmap.NodeInfo.Types.Attribute.Parser);
    private readonly pbc::RepeatedField<global::NeoFS.API.v2.Netmap.NodeInfo.Types.Attribute> attributes_ = new pbc::RepeatedField<global::NeoFS.API.v2.Netmap.NodeInfo.Types.Attribute>();
    /// <summary>
    /// Carries list of the NeoFS node attributes in a key-value form. Key name
    /// must be a node-unique valid UTF-8 string. Value can't be empty. NodeInfo
    /// structures with duplicated attribute names or attributes with empty values
    /// will be considered invalid.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::NeoFS.API.v2.Netmap.NodeInfo.Types.Attribute> Attributes {
      get { return attributes_; }
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 4;
    private global::NeoFS.API.v2.Netmap.NodeInfo.Types.State state_ = global::NeoFS.API.v2.Netmap.NodeInfo.Types.State.Unspecified;
    /// <summary>
    /// Carries state of the NeoFS node.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::NeoFS.API.v2.Netmap.NodeInfo.Types.State State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PublicKey != other.PublicKey) return false;
      if (Address != other.Address) return false;
      if(!attributes_.Equals(other.attributes_)) return false;
      if (State != other.State) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (PublicKey.Length != 0) hash ^= PublicKey.GetHashCode();
      if (Address.Length != 0) hash ^= Address.GetHashCode();
      hash ^= attributes_.GetHashCode();
      if (State != global::NeoFS.API.v2.Netmap.NodeInfo.Types.State.Unspecified) hash ^= State.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (PublicKey.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PublicKey);
      }
      if (Address.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Address);
      }
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (State != global::NeoFS.API.v2.Netmap.NodeInfo.Types.State.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) State);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (PublicKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PublicKey);
      }
      if (Address.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Address);
      }
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (State != global::NeoFS.API.v2.Netmap.NodeInfo.Types.State.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) State);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeInfo other) {
      if (other == null) {
        return;
      }
      if (other.PublicKey.Length != 0) {
        PublicKey = other.PublicKey;
      }
      if (other.Address.Length != 0) {
        Address = other.Address;
      }
      attributes_.Add(other.attributes_);
      if (other.State != global::NeoFS.API.v2.Netmap.NodeInfo.Types.State.Unspecified) {
        State = other.State;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PublicKey = input.ReadBytes();
            break;
          }
          case 18: {
            Address = input.ReadString();
            break;
          }
          case 26: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
          case 32: {
            State = (global::NeoFS.API.v2.Netmap.NodeInfo.Types.State) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the NodeInfo message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Represents the enumeration of various states of the NeoFS node.
      /// </summary>
      public enum State {
        /// <summary>
        /// Unknown state.
        /// </summary>
        [pbr::OriginalName("UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Active state in the network.
        /// </summary>
        [pbr::OriginalName("ONLINE")] Online = 1,
        /// <summary>
        /// Network unavailable state.
        /// </summary>
        [pbr::OriginalName("OFFLINE")] Offline = 2,
      }

      /// <summary>
      /// Administrator-defined Attributes of the NeoFS Storage Node.
      ///
      /// `Attribute` is a Key-Value metadata pair. Key name must be a valid UTF-8
      /// string. Value can't be empty.
      ///
      /// Node's attributes are mostly used during Storage Policy evaluation to
      /// calculate object's placement and find a set of nodes satisfying policy
      /// requirements. There are some "well-known" node attributes common to all the
      /// Storage Nodes in the network and used implicitly with default values if not
      /// explicitly set:
      ///
      /// * Capacity \
      ///   Total available disk space in Gigabytes.
      /// * Price \
      ///   Price in GAS tokens for storing one GB of data during one Epoch. In node
      ///   attributes it's a string presenting floating point number with comma or
      ///   point delimiter for decimal part. In the Network Map it will be saved as
      ///   64-bit unsigned integer representing number of minimal token fractions.
      /// * Subnet \
      ///   String ID of Node's storage subnet. There can be only one subnet served
      ///   by the Storage Node.
      /// * Locode \
      ///   Node's geographic location in
      ///   [UN/LOCODE](https://www.unece.org/cefact/codesfortrade/codes_index.html)
      ///   format approximated to the nearest point defined in standard.
      /// * Country \
      ///   Country code in
      ///   [ISO 3166-1_alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
      ///   format. Calculated automatically from `Locode` attribute
      /// * Region \
      ///   Country's administative subdivision where node is located. Calculated
      ///   automatically from `Locode` attribute based on `SubDiv` field. Presented
      ///   in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) format.
      /// * City \
      ///   City, town, village or rural area name where node is located written
      ///   without diacritics . Calculated automatically from `Locode` attribute.
      ///
      /// For detailed description of each well-known attribute please see the
      /// corresponding section in NeoFS Technical specification.
      /// </summary>
      public sealed partial class Attribute : pb::IMessage<Attribute> {
        private static readonly pb::MessageParser<Attribute> _parser = new pb::MessageParser<Attribute>(() => new Attribute());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Attribute> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::NeoFS.API.v2.Netmap.NodeInfo.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Attribute() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Attribute(Attribute other) : this() {
          key_ = other.key_;
          value_ = other.value_;
          parents_ = other.parents_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Attribute Clone() {
          return new Attribute(this);
        }

        /// <summary>Field number for the "key" field.</summary>
        public const int KeyFieldNumber = 1;
        private string key_ = "";
        /// <summary>
        /// Key of the node attribute.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Key {
          get { return key_; }
          set {
            key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 2;
        private string value_ = "";
        /// <summary>
        /// Value of the node attribute.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Value {
          get { return value_; }
          set {
            value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "parents" field.</summary>
        public const int ParentsFieldNumber = 3;
        private static readonly pb::FieldCodec<string> _repeated_parents_codec
            = pb::FieldCodec.ForString(26);
        private readonly pbc::RepeatedField<string> parents_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Parent keys, if any. For example for `City` it could be `Region` and
        /// `Country`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> Parents {
          get { return parents_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Attribute);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Attribute other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Key != other.Key) return false;
          if (Value != other.Value) return false;
          if(!parents_.Equals(other.parents_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Key.Length != 0) hash ^= Key.GetHashCode();
          if (Value.Length != 0) hash ^= Value.GetHashCode();
          hash ^= parents_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Key.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Key);
          }
          if (Value.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Value);
          }
          parents_.WriteTo(output, _repeated_parents_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Key.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
          }
          if (Value.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
          }
          size += parents_.CalculateSize(_repeated_parents_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Attribute other) {
          if (other == null) {
            return;
          }
          if (other.Key.Length != 0) {
            Key = other.Key;
          }
          if (other.Value.Length != 0) {
            Value = other.Value;
          }
          parents_.Add(other.parents_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Key = input.ReadString();
                break;
              }
              case 18: {
                Value = input.ReadString();
                break;
              }
              case 26: {
                parents_.AddEntriesFrom(input, _repeated_parents_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
